  # grpc核心概念

## 简介

grpc可以使客户端像调用本地对象一样直接调用服务器应用程序的方法，从而更轻松创建分布式应用程序和服务。

基于服务定义的思想，指定可以远程调用的方法及其参数和返回类型。

* 在服务器端，服务器实现这个接口并运行一个gRPC服务器来处理客户端调用。
* 在客户端，客户端有一个存根（stub），它提供与服务器相同的方法。

![alt text](/grpc/image/grpc框架.png)

gRPC 客户端和服务器可以在各种环境中运行并相互通信，并且可以用 gRPC 支持的任何语言编写。

## protobuf

默认情况下，gRPC 使用 Protocol Buffers 序列化数据结构，通过 proto 文件中定义 gRPC 服务，并将 RPC 方法参数和返回类型指定为协议缓冲区消息。

```(proto)
// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}
```

gRPC 使用 protoc 从原始文件生成代码：

* gRPC 客户端和服务器代码
* 用于填充、序列化和检索消息类型的 protobuf 代码。

## 核心概念、架构和生命周期

### 服务定义

gRPC 基于定义服务的思想，指定可以远程调用的方法及其参数和返回类型。默认情况下，gRPC 使用 protobuf 作为接口定义语言（IDL， Interface Definition Language ），用于描述服务接口和消息结构。

grpc运行定义四种方法：

* **一元 RPC**：客户端向服务器发送单个请求并获取单个响应，就像正常的函数调用。

```(rpc)
rpc SayHello(HelloRequest) returns (HelloResponse);
```

* **服务器流式 RPC**：客户端向服务器发送请求并获取流以读回一系列消息。客户端从返回的流中读取，直到没有更多消息为止。 **gRPC 保证单个 RPC 调用内的消息排序**。

```(rpc)
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

* **客户端流式 RPC**：客户端写入一系列消息并将其发送到服务器，同样使用提供的流。客户端完成消息写入后，它会等待服务器读取消息并返回响应。 **gRPC 同样保证单个 RPC 调用内的消息排序。**

```(rpc)
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

* **双向流式 RPC**：双方使用读写流发送一系列消息。这两个流独立运行，**客户端和服务器按照任何顺序读取和写入**：例如，服务器可以在写入响应之前等待接收所有客户端消息，或者可以交替读取消息然后写入消息，或其他一些读和写的组合。每个流的消息都有序。

```(rpc)
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

### API使用步骤

1. 定义 .proto 文件
2. 使用 protoc 生成客户端, 服务器代码
3. 用户通常在客户端调用这些 API，并在服务器端实现相应的 API

* 在服务器端，服务器实现服务声明的方法并运行 gRPC 服务器来处理客户端调用。 gRPC 基础设施解码传入请求、执行服务方法并对服务响应进行编码。
* 在客户端，客户端有一个称为存根（stub ）的本地对象，它实现与服务相同的方法。然后，客户端可以在本地对象上调用这些方法，并且这些方法将调用的参数包装在合适的 protobuf 消息类型中，将请求发送到服务器，并返回服务器的响应。

### RPC生命周期

* ***一元 RPC*** : 客户端发送单个请求并返回单个响应
  * 客户端调用存根方法，服务器接收客户端元数据、方法名称和截止时间。
  * 服务器可以立即发回自己的初始元数据（必须在任何响应之前发送），或者等待客户端的请求消息。首先发生的是特定于应用程序的。
  * 一旦服务器收到客户端的请求消息，它就会执行创建和填充响应所需的任何工作。然后，响应连同状态详细信息（状态代码和可选状态消息）以及可选的尾随元数据一起返回给客户端（如果成功）。
  * 如果响应状态为 OK，则客户端收到响应，从而完成客户端的调用。
* ***服务器流式 RPC***
  * 服务器流式 RPC 与一元 RPC 类似，不同之处在于服务器返回消息流以响应客户端的请求。**发送所有消息后，服务器的状态详细信息（状态代码和可选的状态消息）和可选的尾随元数据将发送到客户端**。这样就完成了服务器端的处理。客户端在收到所有服务器消息后即完成。
* ***客户端流式 RPC***
  * 客户端流式 RPC 与一元 RPC 类似，不同之处在于客户端向服务器发送消息流而不是单个消息。**服务器通常但不一定在收到所有客户端的消息之后，以单个消息（及其状态详细信息和可选的尾随元数据）进行响应**。
* ***双向流式 RPC***
  * 在双向流式 RPC 中，调用由客户端调用方法发起，服务器接收客户端元数据、方法名称和截止时间。服务器可以选择发回其初始元数据或等待客户端开始流式传输消息。
  * 客户端和服务器端流处理是特定于应用程序的。**由于两个流是独立的，因此客户端和服务器可以按任意顺序读写消息**。例如，服务器可以等到接收到客户端的所有消息后再写入消息，或者服务器和客户端可以玩“乒乓球”――服务器收到请求，然后发回响应，然后客户端发送基于响应的另一个请求.

* ***截止日期/超时***
  * **gRPC 允许客户端指定 RPC 调用的截至时间** `DEADLINE_EXCEEDED`。在服务器端，服务器可以查询特定的 RPC 是否超时，或者还剩多少时间来完成 RPC。
  * **指定截止日期或超时是特定于语言的**：某些语言 API 根据超时（持续时间）工作，而某些语言 API 根据截止日期（固定时间点）工作，并且可能有也可能没有默认截止日期。

* ***RPC 调用结束***
  * 在gRPC中，**客户端和服务器都对调用的成功做出独立的本地判断，并且它们的结论可能不匹配**。这意味着，例如，您的 RPC 可能在服务器端成功完成（“我已发送所有响应！”），但在客户端失败（“响应在我的截止日期后到达！”）。服务器也可能决定在客户端发送其所有请求之前完成。

* ***取消 RPC 调用***
  * 客户端或服务器都可以随时取消 RPC。取消会立即终止 RPC，从而不再执行进一步的工作。
  * 警告 : 取消之前所进行的操作不会回滚。

* ***元数据***
  * 元数据是有关特定 RPC 调用的信息（例如身份验证详细信息），采用**键值对列表**的形式，其中键是字符串，值通常是字符串，但也可以是二进制数据。
  * 密钥不区分大小写，由 ASCII 字母、数字和特殊字符 `-`, `_`, `.`组成, 并且不能以`grpc-`开头。二进制值的键以`-bin`结尾，而 ASCII 值键则不然。
  * **gRPC不使用用户定义的元数据**，这允许客户端向服务器提供与调用相关的信息，反之亦然。**对元数据的访问取决于语言**。

* **channel**
  * gRPC 通过`channel`来连接特定主机和端口上的 gRPC 服务器。**它在创建客户端存根(stub)时使用**。
  * **客户端可以指定通道参数来修改 gRPC 的默认行为**，例如打开或关闭消息压缩。通道具有状态，包括`connected`和`idle`。
  * gRPC 如何处理关闭通道取决于语言。某些语言还允许查询通道状态。
