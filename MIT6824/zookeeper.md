# Zookeeper

ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

Zookeeper 聪明的从多个副本读数据从而提升了性能，但同时又牺牲了一些一致性；另 Zookeeper 的 API 设计使得 Zookeeper 成为一个通用的协调服务，这是一个简单的 put/get 服务所不能实现，这些 API 可以写出类似 **mini-transaction** 的代码，也可以帮创建锁。

## zookeeper的一致性保证

1. **Linearizable writes**：写请求满足线性一致（多client有序），Zookeeper可以确保一次只处理一个写请求，并且所有的副本都能看到一致的写请求顺序。
2. **FIFO client order**：一个特定客户端的连续请求，后来的请求总是能看到相比较于前一个请求相同或者更晚的状态。
   1. zookeeper 确保在一个连续的请求序列中后续的读请求会在前一个读请求对应的位置或者更后的位置执行。实现原理为，每条数据会携带 zxid 标签，后面的读请求会携带前一次读请求所访问数据的 zxid 标签，如果当前读请求访问的副本中数据的标签小于 zxid 时，证明该副本还未将数据更新至 zxid 位置，此时该副本会拒绝客户端的读请求。
   2. 若客户端执行了一次写请求然后立即读同一份数据，那么副本可能会暂缓客户端的读请求，等到对应zxid的写请求再执行读请求。

## zookeeper 特点

1. **顺序一致性**：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中去。
2. **原子性**：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，即整个集群要么都成功应用了某个事务，要么都没有应用。
3. **单一视图**：无论客户端连接的是哪个 Zookeeper 服务器，其看到的服务端数据模型都是一致的。
4. **可靠性**：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会一直被保留，除非有另一个事务对其进行了变更。
5. **实时性**：Zookeeper 保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。

## zookeeper 集群

Zookeeper 是一个由多个 server 组成的集群,一个 leader，多个 follower。leader 为客户端服务器提供读写服务，除了leader外其他的机器只能提供读服务。

每个 server 保存一份数据副本全数据一致，分布式读 follower，写由 leader 实施更新请求转发，由 leader 实施更新请求顺序进行，来自同一个 client 的更新请求按其发送顺序依次执行数据更新原子性，一次数据更新要么成功，要么失败。

全局唯一数据视图，client 无论连接到哪个 server，数据视图都是一致的实时性，在一定事件范围内，client 能读到最新数据。

## zookeeper 节点

在Zookeeper中，“节点"分为两类，第一类同样是指构成集群的服务器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。

Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree），由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。

![alt text](/MIT6824/zookeeper/namespace.png){:height="70%" width="70%"}

### 节点类型

在Zookeeper中，node可以分为**持久节点**、**临时节点**和**顺序节点**。通过组合可以生成如下四种类型节点：

* **PERSISTENT**：持久节点,节点创建后便一直存在于Zookeeper服务器上，直到有删除操作来主动清楚该节点。
* **PERSISTENT_SEQUENTIAL**：持久顺序节点,相比持久节点，其新增了顺序特性，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。在创建节点时，会自动添加一个数字后缀，作为新的节点名，该数字后缀的上限是整形的最大值。
* **EPEMERAL**：临时节点，临时节点的生命周期与客户端会话绑定，客户端失效，节点会被自动清理。同时，Zookeeper规定不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。
* **EPEMERAL_SEQUENTIAL**：临时顺序节点,在临时节点的基础添加了顺序特性。

## zookeeper API

**CREATE**(PATH，DATA，FLAG)

* PATH：节点路径名
* DATA：节点数据
* FLAG：节点类型

若返回为 true，那么说明这个节点之前不存在，调用者为第一个创建该文件的客户端；否则说明该节点之前已存在。如果有多个客户端同时创建同一个文件，实际成功创建节点（获得了锁）的那个客户端是可以通过CREATE的返回知道的。

---

**DELETE**(PATH，VERSION)

* PATH：节点路径名
* VERSION：版本号

每一个znode都有一个表示当前版本号的version，当znode有更新时，version也会随之增加。对于delete和一些其他的update操作，可以增加一个version参数，表明当且仅当znode的当前版本号与传入的version相同时才执行操作（CAS）。

---

**EXIST**(PATH，WATCH)

* PATH：节点路径名
* WATCH：监听节点的变化

通过指定 watch 可以监听对应文件的变化。不论文件是否存在，都可以设置 watch 为true，这样 Zookeeper 可以确保如果文件有任何变更，例如创建，删除，修改，都会通知到客户端。

---

**GETDATA**(PATH，WATCH)

* PATH：节点路径名
* WATCH：监听节点的变化

---

**SETDATA**(PATH，DATA，VERSION)

* PATH：节点路径名
* DATA：节点数据
* VERSION：版本号

如果传入了version，那么Zookeeper当且仅当文件的版本号与传入的version一致时，才会更新文件。提供 **_读-更改-写_** 的原子操作（mini-transaction）。

---

**LIST**(PATH)

* PATH：节点路径名

入参是目录的路径名，返回的是路径下的所有文件。

## zookeeper 应用

### 配置文件管理

zookeeper 可以实现在分布式服务中使用动态配置，客户端通过将 `GETDATA` 的 `watch` 参数设置为 true 来保证读取到最新的配置文件，如果储存配置文件的 znode 节点更新，则会通知客户端重新读取。

如果存在多个配置文件且要求在完全更新前不允许客户端进行访问，则可以先创建一个 ready 节点，在客户端访问配置文件前先使用 `EXIST` 判断配置文件是否准备就绪。

### 服务管理

在分布式系统中，客户端可能想要启动一个主进程和几个工作进程，但是启动进程是由调度器完成的，因此客户端无法提前知道可以给工作进程提供连接主机的地址和端口信息。可以使用 ZooKeeper 通过约会节点（rendezvous znode）来处理这种情况。

客户端将zr的完整路径名作为主进程和工作进程的启动参数。当主进程启动时，它会填写 zr 所使用的地址和端口信息。当工作进程启动时，它们将设置监视器（watch）为true来读取 zr。如果 zr 尚未配置，则工作进程将等待被通知 zr 更新。如果 zr 是一个临时节点，主进程和工作进程可以监视 zr 被删除，并在客户端结束时清理自己。

### 组成员管理

利用临时节点来实现组成员资格。具体来说，我们利用临时节点允许我们查看创建该节点的会话状态这一事实。我们首先指定一个 ZNode zg 来表示组。当组中的一个进程启动时，它在 zg 下创建一个临时的子节点。

如果每个进程都有一个唯一的名字或标识符，那么就用这个名字作为子节点的名字；否则，进程使用带有 `SEQUENTIAL` 标志的 ZNode 来获取一个唯一的名称分配。进程可以在子节点的数据中存放进程信息，例如进程使用的地址和端口。

进程可以通过简单地列出 zg 的子进程来获取组信息。如果进程想要监视组成员的变化，进程可以将 `WATCH` 标志设置为 TRUE，并在收到更改通知时刷新组信息（始终将`WATCH` 标志设置为 TRUE）。

### 可拓展锁

```(shell)
CREATE("f", data, sequential=TRUE, ephemeral=TRUE)
WHILE TRUE:
    LIST("f*")
    IF NO LOWER #FILE: RETURN
    IF EXIST(NEXT LOWER #FILE, watch=TRUE):
        WAIT
```

按照每个客户端的请求顺序创建 `ephemeral` `sequential` 节点(注意这里是节点具有`ephemeral`标志位保证节点崩溃后能自动释放锁)，每一个 `sequential` 节点都赋予了递增的序号，每一个客户端等待其前一个比自己序号小的 `sequential` 节点删除即可获取锁。

此种实现方式避免了羊群效应（Herd Effect），因为释放锁时只会唤醒一个客户端，而非惊醒所有客户端。

### 读写锁

![alt text](/MIT6824/zookeeper/RWlock.png){:height="75%" width="75%"}

对于写锁，为序号比自己小的节点添加 watch 标志位，若该节点释放，则获取锁。

对于读锁，为序号比自己小的 write 节点添加 watch 标志位，若该节点释放，则获取锁。
